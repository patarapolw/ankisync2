#! /usr/bin/env python3
# -*- coding: utf-8 -*-

#
# Anᴵkisync2_api.py, An(implementation)ki Api sample generator from the docs
# Copyright (C) 2021 Olivier Lutzwiller <sosie@sos-productions.com>
#
# This program is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General
# Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied
# warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
# details.
#
# You should have received a copy of the GNU Affero General Public License along with this program.  If not, see
# <http://www.gnu.org/licenses/>.
#

import requests
import bs4

#doc: https://www.crummy.com/software/BeautifulSoup/bs4/doc/#navigablestring
from bs4 import BeautifulSoup
import os

import json

#Here is the API doc of ankiweb SOAP with a soup of HTML unclosed tags
#fortunately html5-lib will solves this , a big jump and benchmark of BeautifySoup for me
url = 'https://foosoft.net/projects/anki-connect/'

file_api="ankisync2_api.html"
use_cache= True #We used cached version to fix html locally
show_sample = False #for debug
    
def file_read_content(file):
    file = open(file, 'r')
    content=file.read()
    file.close()
    return content

def file_save_content(file, content):
    file = open(file, 'w')
    file.write(content)
    file.close()

def file_exists(file):
    return os.path.isfile(file)
   
print("Anᴵkisync2_api.py, An(implementation)ki Api sample generator")
print("==================================")
    
if not  file_exists(file_api) or not use_cache:
    response = requests.get(url)
    if(response.status_code == 200):
        content=response.text
        # We don't use classical "html.parser" but
        #"html5lib" instead, this will fix missing non closed tags
        # like php's tidy fix...
        html_file = BeautifulSoup(content, "html5lib")
        content=html_file.prettify()
        file_save_content(file_api, content)
    else:
        raise "Impossible to get file api"
else:
    print("Using cached "+file_api)
    content=file_read_content(file_api)

def get_siblings(element):
    element_siblings=element.next_siblings
    siblings = [sibling for sibling in element_siblings if element_siblings is not None and isinstance(sibling, bs4.element.Tag)]
    return siblings

def get_children(element):
    element_children=element.children
    children = [child for child in element_children if element_children is not None and isinstance(child, bs4.element.Tag)]
    return children
    
# Function to remove tags
def remove_tags(soup,flat=False):
    if(flat):
        for data in soup(['style', 'script']):
            # Remove tags
            data.decompose()
            
        clean=' '.join(soup.stripped_strings).replace("\n"," ")
    else:
       clean=''.join(soup.strings)
    return clean   
    
def get_next_tag_sibling(root):
    """
     Behaves like root.find_next_sibling but without arguments
    """
    siblings=get_siblings(root)
    i=0
    while True:
        sibling=siblings[i]
        if isinstance(sibling, bs4.element.Tag):
            break
        i=i+1
    return sibling

"""
    Get the sibling container of tag matching id
  <tag id="#id">
  </tag>
  <container>
  
  </container>
"""
def fetch_sibling_container_from(html_file, tag, id):
    return get_next_tag_sibling(html_file.find(tag, {'id': id}))
   
    

html_file = BeautifulSoup(content,  "html.parser")
#print(html_file.prettify())
#equivalent to .findAll('h3', {'id': 'supported-actions'},limit=1) ?
#supported_actions=html_file.select("h3[id='supported-actions']")

#Fetch the first sibling 'p', by jumping over '\n'
sibling=fetch_sibling_container_from(html_file,'h3','supported-actions')

#ul
sibling=get_next_tag_sibling(sibling)

#now we have the ul tag, containing the list of anchors with refs!
supported_actions=sibling.findAll('a') #limit=8
for supported_action in supported_actions:
    actions=supported_action.get_text().strip()
    if "Actions" in actions:
        print("~~~~~~~~~")
        print(actions)
        print("~~~~~~~~~")
        supported_action_anchor=supported_action["href"].lstrip("#")
        
        file_actions=supported_action_anchor+".py"
        file = open(file_actions, 'w')
        file.write("""#! /usr/bin/env python3
# -*- coding: utf-8 -*-

# """+file_actions+""" : implementation of the """+actions+"""
# Author: sosie <sosie@sos-productions.com> (08.2021)
# Note: this is a direct copy, autogenerated from the fixed API docs found on FooSoft productions website
# using Anᴵkisync2_api.py script. Some examples may not work
# due to the missing test database collections.anki2 in the current user anki directory
# See : https://foosoft.net/projects/anki-connect/#"""+supported_action_anchor +"""
#
#sudo pip3 install ankisync2
import os

from ankisync2.ankiconnect import  ankiconnect as invoke

        """)
        ul=fetch_sibling_container_from(html_file, "h4", supported_action_anchor) 
        methods_defs=get_children(ul)
        
        # importing functools for reduce()
        import functools
        
        import re
        
        for method_def in methods_defs:
            print(chr(13))
            method_def_blocks=method_def.select("p,pre")
            
            #Collapses the middle (ie multiples paragraphs) the method may have into one
            #getIntervals 7, guiAddCards 6, storeMediaFile 13, requestPermission 5, createModel 4, addNote 3
            
            
            #======= METHOD NAME =================
            
            """
            [<p>
<strong>
       getEaseFactors
      </strong>
</p>
            """    
            start_block=method_def_blocks[0:1]
            strong=method_def_blocks[0].find("strong")
            method_name=strong.get_text().strip()
            
            # Note: some methods has many paragraphs for its descrition
            # we must collapse them into one
            nb_blocks=len(method_def_blocks)
            
            #if(nb_blocks != 6):
            #        print("#######" +method_name +" HAS UNUSAL "+str(nb_blocks))
            
            #print("~~E~~"+str(len(method_def_blocks)))
            sample_result_header="".join(method_def_blocks[nb_blocks-2].stripped_strings)
            #sample_result_header='Sample result :'
            x = re.match('Sample result ([0-9]+)', sample_result_header)
            if(x):
                samples=int(x.group(1))
            else:
                samples=1
           
            #raise Exception("Stop")
            
            #middle is the glue of descriptions for the method   
            middle=[child for child in method_def_blocks[1:-4*samples]]
            
            def reduce_tag(x,y):
                head="######"+str(type(x))+"###>"
                tail="<###"+str(type(y))+"#######"
                if(show_sample):
                    print(head,x,"<=+=>",y,tail)
                if(x is None):
                    v=y
                else:
                    if(y is None):
                        v=x
                    else:
                        #x.set_text(x.get_text()+y.get_text())
                         x.string = x.get_text()+y.get_text()
                    v=x
                return v
            
            def reduce(function, iterable, initializer=None):
                it = iter(iterable)
                if initializer is None:
                    value = next(it)
                else:
                    value = initializer
                for element in it:
                    value = function(value, element)
                return value
                
            #functools.reduce(reduce, middle)
            middle=reduce(reduce_tag, middle)
            
            """
            middle=method_def_blocks[1:-4]
            first = middle[0]
            it = iter(middle)
            value = next(it)
            items=list(first.stripped_strings)
            for n in it:
                if isinstance(n, bs4.element.Tag) : #and n.name == 'p':
                    if n.text:
                        #first.append(n.text)
                        print(type(first),type(n))
                        items.append(n.text)
            first.string=' '.join(items)
            middle=first
            """
            end_blocks=method_def_blocks[-4*samples:]
            
            
            
            
            #======= METHOD DESCRIPTION ===============
            

                    
            """
            <p>
      Returns an array with the ease factor for each of the given cards (in the same order).
     </p>
            """
            desc=middle #method_def_blocks[1] #p
            method_desc=remove_tags(desc,True)#''.join(desc.contents) #get_text().strip()
            
    
            #sample=end_block[0] method_def_blocks[2] #em :  Sample request 
            sample=end_blocks[1] #method_def_blocks[3] #pre
            """
            <pre style="color:#93a1a1;background-color:#002b36" tabindex="0">
            {
                <span style="color:#268bd2">"action"</span>: <span style="color:#2aa198">"getEaseFactors"</span>,
                <span style="color:#268bd2">"version"</span>: <span style="color:#2aa198">6</span>,
                <span style="color:#268bd2">"params"</span>: {
                    <span style="color:#268bd2">"cards"</span>: [<span style="color:#2aa198">1483959291685</span>, <span style="color:#2aa198">1483959293217</span>]
                }
            }
            </pre>
            """
           
            
            sample_clean=remove_tags(sample)
           
            if("{" == sample_clean.strip()[0]):
                if(show_sample):
                    print("~S~"+method_name+"~~")
                    print(sample_clean)
                    print("~")
                sample_props=json.loads(sample_clean)
            else:
                sample_props=sample
                
            #print(sample_props["action"])
            if "params" in sample_props:
                params=list(sample_props["params"].keys())
                method_params='["'+'","'.join(params)+'"]'
            else:
                method_params=""
                
            
            #sample_props=[span.get_text() for span in spans]
            
            #result=end_blocksmethod_def_blocks[4] #end_blocksem :  Sample result
            """
            <p>
<em>
       Sample result
      </em>
      :
     </p>, <pre style="color:#93a1a1;background-color:#002b36" tabindex="0">{
    <span style="color:#268bd2">"result"</span>: [<span style="color:#2aa198">4100</span>, <span style="color:#2aa198">3900</span>],
    <span style="color:#268bd2">"error"</span>: <span style="color:#cb4b16">null</span>
}
</pre>
            """
            result=end_blocks[3] #method_def_blocks[5]
            result_clean=remove_tags(result, True)
            
            if "{" == result_clean.strip()[0]:
                if(show_sample):
                    print("~R~"+method_name+"~~")
                    print(result_clean)
                    print("~")
                result_props=json.loads(result_clean)
            else:
               result_props=result
            
            method_def=method_name+'('+method_params.strip("[]").replace('"',"").replace(',',", ")+'):'+str(result_clean)
            print(method_def)
            print("-"*int(len(method_def)*4/3))
            print(method_desc)
            print(chr(13))
            
            file.write(chr(13))
            file.write('"""'+chr(13)+'===================================='+chr(13)+method_desc+chr(13)+"===================================="+chr(13)+'"""')
            file.write(chr(13))
            
            #to build param call of invoke
            params=[]
            
            #set params values, method has param(s)
            if "params" in sample_props:
                for key, value in sample_props["params"].items():
                    
                    #Json beautify, we have to deal with unicode escaping and resolve \u
                    # as in https://qastack.fr/programming/18337407/saving-utf-8-texts-in-json-dumps-as-utf8-not-as-u-escape-sequence
                    json_string=json.dumps(value, ensure_ascii=False, indent=4).encode('utf8')
                    value=json_string.decode()
                    
                    file.write(chr(13)+key+"="+str(value))
                    params.append(key+'='+key)
                    
                file.write(chr(13))
                
            if(len(params) >0):
                file.write('result = invoke("'+method_name+'", '+', '.join(params)+')')
            else:
                file.write('result = invoke("'+method_name+'")')
                
            file.write(chr(13))    
            file.write('#Example of result: '+str(result_clean))
            file.write(chr(13))
            
            
     
                
        file.close()



